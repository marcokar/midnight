
var db = require('./dbconn.js'); // Connect to database
var aux = require('./auxiliary.js');

var running = false;

////////////////////////////////////
// MAIN FUNCTIONS //////////////////
////////////////////////////////////

process.on('message', (m) => {

  var procPars = aux.decJson(m);

  switch (procPars.act) {

    case "HANDSHAKE":
      db.updateData('Users/' + procPars.usr, {
        nick: procPars.usr,
        sid: procPars.sid,
        time: Date.now()
      });
      console.log('User ' + procPars.usr + ' connected with sid ' + procPars.sid);
      break;

    case "MSEARCH":
      searchRequest(procPars);
      break;

    case "MDROP":
      dropMatch(procPars.mid);
      break;

    default:
      console.log('ReqManager: no action');
      break;

  }

});

function searchOpponents() {

  if (running == false) {

    db.getSnapshot('Requests', function (snapshot) {

      running = true;
      snap = snapshot.val();
      procPars = new Object();

      console.log('ReqManager: matchmaking');

      for (var r in snap) {
        for (var o in snap) {
          if (o != r) {
            if (snap[o].status == 0) {

              snap[r].status = 1;
              snap[o].status = 1;
              procPars['usr1'] = r;
              procPars['usr2'] = o;

              mid = db.push('Matches');
              db.updateData('Matches/' + mid, {
                status: 0,
                user1: procPars.usr1,
                user2: procPars.usr2,
              });

              // Update user 1 request
              db.updateData("Requests/" + procPars.usr1, {
                status: 1,
                mid: mid
              });

              // Update user 2 request
              db.updateData("Requests/" + procPars.usr2, {
                status: 1,
                mid: mid
              });

              // Send match create request to core
              process.send(aux.encJson({
                act: "MCREATE",
                sts: 0,
                usr1: procPars.usr1,
                usr2: procPars.usr2,
                mid: mid
              }));

            }
          }
        }
      }

      running = false;

    });

  }

}

function searchRequest(procPars) {

  console.log('ReqManager: managing request');

  db.getSnapshot('Requests/' + procPars.usr, (function () {
    return function (snapshot) {

      // Check if request is already there
      if (snapshot.exists()) {

        // Check if request is still pending
        if (snapshot.child("status").val() == 1) {

          // Fetch request data to user
          process.send(aux.encJson({
            act: "MINFO",
            sts: 1,
            usr: snapshot.key,
            mid: snapshot.child("mid").val()
          }));

        } else {

          // Search opponents
          searchOpponents();

        }

      } else {

        // Insert new request
        db.updateData('Requests/' + procPars.usr, {
          status: 0,
          mid: 0
        });

        // Search opponents
        searchOpponents();

      }

    }
  })(procPars));

}

function dropSearchRequest(mid) {
  db.getSnapshotByChild('Requests', 'mid', mid, function (snapshot) {
    snapshot.forEach(function (s) {
      console.log('Delete request for ' + s.key);
      db.deleteData('Requests/' + s.key);
    })
  });
}

function dropMatch(mid) {
  db.deleteData('Matches/' + mid);
  dropSearchRequest(mid);
}
